from getpass import getpass
from math import ceil
from time import sleep
import requests
import json

# password format function
def get_valid_pass(msg:str, ln=100):
    invalid_input = True
    while invalid_input:
        inp = getpass(msg + ": ").strip()
        invalid_input = len(inp) < ln
        if invalid_input:
            print("invalid " + msg + ", please try again.")
        
    return inp


# storing secrets in a class for convenience
class Spt():
    def __init__(self):
        self.client_id = input("user_id:").strip() #get_valid_pass("client_id", 2)
        self.client_oauth = get_valid_pass("client_oauth")
        self.headers={
            "Content-Type": "application/json",
            "Authorization": f"Bearer {self.client_oauth}"
        }


def create_playlist(spt:Spt, name:str, description:str):
    request_body = json.dumps({
        "name": name,
        "description": description,
        "public": True
    })

    response = requests.post(
        f"https://api.spotify.com/v1/users/{spt.client_id}/playlists",
        data=request_body,
        headers=spt.headers
    )
    response_json = response.json()
    if response.status_code != 201:
        raise Exception(response_json)
    
    return response_json["id"]

# reads file into a list of ids with type
def parse_text(filename:str):
    res = []
    # example link:
    # https://open.spotify.com/album/5l5m1hnH4punS1GQXgEi3T?si=gZH_1PCoSBirFUg728jrzA
    # the si part is a fingerprint of user + time
    data = []
    with open(filename, "r") as f:
        data = f.readlines()
    
    for link in data:
        id_type, tail = link.replace("https://open.spotify.com/", "").split("/")
        link_id = tail.split("?")[0]
        res.append((id_type, link_id))
        
    return res

def get_album_songs(uid:str, spt:Spt):
    response = requests.get(
        f"https://api.spotify.com/v1/albums/{uid}/tracks",
        headers=spt.headers
    )
    
    # did you know that a single album could be 2.7k lines? (~50k characters)
    if response.status_code != 200:
        raise Exception(response.json())

    response_json = response.json()
    album_uris = []
    for item in response_json["items"]:
        album_uris.append(item["uri"])
    
    return album_uris
 
 
def get_uris(ids, spt):
    n = len(ids)
    uris = []
    for i, (utype, uid) in enumerate(ids):
        print(f"getting item {i+1}/{n}")
        
        if utype == "track":
            uris.append(f"spotify:track:{uid}")
        elif utype == "album":
            uris.extend(get_album_songs(uid, spt))
        else:
            raise Exception("invalid id type")
    
    return uris
 
# APPARENTLY ITEM == TRACK
# which menas I have to fetch songs from albums ;-;
# did you know that I can add a maximum of 100 tracks per request?
def add_songs_to_playlist(spt:Spt, uris:list[str], playlist_id):
    assert len(uris) <= 100
    
    response = requests.post(
        f"https://api.spotify.com/v1/playlists/{playlist_id}/tracks",
        data = json.dumps(uris),
        headers=spt.headers
    )

    # check for valid response status
    if response.status_code != 201:
        raise Exception(response.json())

    # added sleep juuust in case if spt servers don't like getting ddos'ed
    sleep(0.5)
    return response.json()

def chunks(lst, n):
    """Yield successive n-sized chunks from lst."""
    for i in range(0, len(lst), n):
        yield lst[i:i + n]


def main():
    # variables
    ids = parse_text("music.txt")
    spt = Spt()
    desc = "I've recommended my friend a few tracks/albums, and decided to compile them here. \
    Made with https://github.com/viktor-grunwaldt/spotify-playlist-maker"
    
    # getting uri's
    new_pl_id = create_playlist(spt,"autogenerated playlist", desc)
    uris = get_uris(ids, spt)
    print(f"{len(uris)} songs found")
    n = ceil(len(uris)/100)
    # adding to playlist
    for i, chunk in enumerate(list(chunks(uris, 100))):
        print(f"adding chunk {i+1}/{n}")
        add_songs_to_playlist(spt, chunk, new_pl_id)

    
if __name__ == "__main__":
    main()